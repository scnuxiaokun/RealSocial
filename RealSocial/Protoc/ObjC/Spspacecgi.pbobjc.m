// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: spspacecgi.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

 #import "Spspacecgi.pbobjc.h"
 #import "Spcgicomm.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - RSSpspacecgiRoot

@implementation RSSpspacecgiRoot

// No extensions in the file and none of the imports (direct or indirect)
// defined extensions, so no need to generate +extensionRegistry.

@end

#pragma mark - RSSpspacecgiRoot_FileDescriptor

static GPBFileDescriptor *RSSpspacecgiRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"spcgi"
                                                 objcPrefix:@"RS"
                                                     syntax:GPBFileSyntaxProto2];
  }
  return descriptor;
}

#pragma mark - RSStarImg

@implementation RSStarImg

@dynamic hasThumbURL, thumbURL;
@dynamic hasImgURL, imgURL;

typedef struct RSStarImg__storage_ {
  uint32_t _has_storage_[1];
  NSString *thumbURL;
  NSString *imgURL;
} RSStarImg__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "thumbURL",
        .dataTypeSpecific.className = NULL,
        .number = RSStarImg_FieldNumber_ThumbURL,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RSStarImg__storage_, thumbURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "imgURL",
        .dataTypeSpecific.className = NULL,
        .number = RSStarImg_FieldNumber_ImgURL,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RSStarImg__storage_, imgURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RSStarImg class]
                                     rootClass:[RSSpspacecgiRoot class]
                                          file:RSSpspacecgiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RSStarImg__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001H\000\002F\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RSStarVideo

@implementation RSStarVideo

@dynamic hasThumbURL, thumbURL;
@dynamic hasVideoURL, videoURL;

typedef struct RSStarVideo__storage_ {
  uint32_t _has_storage_[1];
  NSString *thumbURL;
  NSString *videoURL;
} RSStarVideo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "thumbURL",
        .dataTypeSpecific.className = NULL,
        .number = RSStarVideo_FieldNumber_ThumbURL,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RSStarVideo__storage_, thumbURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "videoURL",
        .dataTypeSpecific.className = NULL,
        .number = RSStarVideo_FieldNumber_VideoURL,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RSStarVideo__storage_, videoURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RSStarVideo class]
                                     rootClass:[RSSpspacecgiRoot class]
                                          file:RSSpspacecgiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RSStarVideo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001H\000\002H\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RSIdPair

@implementation RSIdPair

@dynamic hasSvrId, svrId;
@dynamic hasClientId, clientId;

typedef struct RSIdPair__storage_ {
  uint32_t _has_storage_[1];
  NSString *clientId;
  uint64_t svrId;
} RSIdPair__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "svrId",
        .dataTypeSpecific.className = NULL,
        .number = RSIdPair_FieldNumber_SvrId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RSIdPair__storage_, svrId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "clientId",
        .dataTypeSpecific.className = NULL,
        .number = RSIdPair_FieldNumber_ClientId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RSIdPair__storage_, clientId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RSIdPair class]
                                     rootClass:[RSSpspacecgiRoot class]
                                          file:RSSpspacecgiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RSIdPair__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001E\000\002H\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RSComment

@implementation RSComment

@dynamic hasCommentId, commentId;
@dynamic hasFromUser, fromUser;
@dynamic hasCreateTime, createTime;
@dynamic hasContent, content;

typedef struct RSComment__storage_ {
  uint32_t _has_storage_[1];
  uint32_t createTime;
  RSIdPair *commentId;
  NSString *fromUser;
  NSString *content;
} RSComment__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "commentId",
        .dataTypeSpecific.className = GPBStringifySymbol(RSIdPair),
        .number = RSComment_FieldNumber_CommentId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RSComment__storage_, commentId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "fromUser",
        .dataTypeSpecific.className = NULL,
        .number = RSComment_FieldNumber_FromUser,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RSComment__storage_, fromUser),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "createTime",
        .dataTypeSpecific.className = NULL,
        .number = RSComment_FieldNumber_CreateTime,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RSComment__storage_, createTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "content",
        .dataTypeSpecific.className = NULL,
        .number = RSComment_FieldNumber_Content,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(RSComment__storage_, content),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RSComment class]
                                     rootClass:[RSSpspacecgiRoot class]
                                          file:RSSpspacecgiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RSComment__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\001I\000\002H\000\003J\000\004G\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RSStar

@implementation RSStar

@dynamic hasStarId, starId;
@dynamic hasType, type;
@dynamic hasAuthor, author;
@dynamic hasCreateTime, createTime;
@dynamic hasImg, img;
@dynamic hasVideo, video;
@dynamic commentListArray, commentListArray_Count;

typedef struct RSStar__storage_ {
  uint32_t _has_storage_[1];
  uint32_t type;
  uint32_t createTime;
  RSIdPair *starId;
  NSString *author;
  RSStarImg *img;
  RSStarVideo *video;
  NSMutableArray *commentListArray;
} RSStar__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "starId",
        .dataTypeSpecific.className = GPBStringifySymbol(RSIdPair),
        .number = RSStar_FieldNumber_StarId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RSStar__storage_, starId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "type",
        .dataTypeSpecific.className = NULL,
        .number = RSStar_FieldNumber_Type,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RSStar__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "author",
        .dataTypeSpecific.className = NULL,
        .number = RSStar_FieldNumber_Author,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RSStar__storage_, author),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "createTime",
        .dataTypeSpecific.className = NULL,
        .number = RSStar_FieldNumber_CreateTime,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(RSStar__storage_, createTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "img",
        .dataTypeSpecific.className = GPBStringifySymbol(RSStarImg),
        .number = RSStar_FieldNumber_Img,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(RSStar__storage_, img),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "video",
        .dataTypeSpecific.className = GPBStringifySymbol(RSStarVideo),
        .number = RSStar_FieldNumber_Video,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(RSStar__storage_, video),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "commentListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(RSComment),
        .number = RSStar_FieldNumber_CommentListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RSStar__storage_, commentListArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RSStar class]
                                     rootClass:[RSSpspacecgiRoot class]
                                          file:RSSpspacecgiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RSStar__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\007\001F\000\002D\000\003F\000\004J\000\005C\000\006E\000\007\000CommentList\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RSReceiver

@implementation RSReceiver

@dynamic hasType, type;
@dynamic userNameArray, userNameArray_Count;

typedef struct RSReceiver__storage_ {
  uint32_t _has_storage_[1];
  uint32_t type;
  NSMutableArray *userNameArray;
} RSReceiver__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.className = NULL,
        .number = RSReceiver_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RSReceiver__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "userNameArray",
        .dataTypeSpecific.className = NULL,
        .number = RSReceiver_FieldNumber_UserNameArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RSReceiver__storage_, userNameArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RSReceiver class]
                                     rootClass:[RSSpspacecgiRoot class]
                                          file:RSSpspacecgiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RSReceiver__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001D\000\002\000UserName\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RSSpace

@implementation RSSpace

@dynamic hasSpaceId, spaceId;
@dynamic hasType, type;
@dynamic hasCreateTime, createTime;
@dynamic hasUpdateTime, updateTime;
@dynamic hasCreator, creator;
@dynamic hasName, name;
@dynamic authorArray, authorArray_Count;
@dynamic hasReceiver, receiver;
@dynamic starListArray, starListArray_Count;

typedef struct RSSpace__storage_ {
  uint32_t _has_storage_[1];
  uint32_t type;
  uint32_t createTime;
  uint32_t updateTime;
  RSIdPair *spaceId;
  NSString *creator;
  NSString *name;
  NSMutableArray *authorArray;
  RSReceiver *receiver;
  NSMutableArray *starListArray;
} RSSpace__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "spaceId",
        .dataTypeSpecific.className = GPBStringifySymbol(RSIdPair),
        .number = RSSpace_FieldNumber_SpaceId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RSSpace__storage_, spaceId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "type",
        .dataTypeSpecific.className = NULL,
        .number = RSSpace_FieldNumber_Type,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RSSpace__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "createTime",
        .dataTypeSpecific.className = NULL,
        .number = RSSpace_FieldNumber_CreateTime,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RSSpace__storage_, createTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "updateTime",
        .dataTypeSpecific.className = NULL,
        .number = RSSpace_FieldNumber_UpdateTime,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(RSSpace__storage_, updateTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "creator",
        .dataTypeSpecific.className = NULL,
        .number = RSSpace_FieldNumber_Creator,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(RSSpace__storage_, creator),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = RSSpace_FieldNumber_Name,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(RSSpace__storage_, name),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "authorArray",
        .dataTypeSpecific.className = NULL,
        .number = RSSpace_FieldNumber_AuthorArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RSSpace__storage_, authorArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "receiver",
        .dataTypeSpecific.className = GPBStringifySymbol(RSReceiver),
        .number = RSSpace_FieldNumber_Receiver,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(RSSpace__storage_, receiver),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "starListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(RSStar),
        .number = RSSpace_FieldNumber_StarListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RSSpace__storage_, starListArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RSSpace class]
                                     rootClass:[RSSpspacecgiRoot class]
                                          file:RSSpspacecgiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RSSpace__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\t\001G\000\002D\000\003J\000\004J\000\005G\000\006D\000\007\000Author\000\010H\000\t\000StarLis"
        "t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RSCreateSpaceReq

@implementation RSCreateSpaceReq

@dynamic hasBaseReq, baseReq;
@dynamic hasSpace, space;

typedef struct RSCreateSpaceReq__storage_ {
  uint32_t _has_storage_[1];
  RSBaseReq *baseReq;
  RSSpace *space;
} RSCreateSpaceReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseReq",
        .dataTypeSpecific.className = GPBStringifySymbol(RSBaseReq),
        .number = RSCreateSpaceReq_FieldNumber_BaseReq,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RSCreateSpaceReq__storage_, baseReq),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "space",
        .dataTypeSpecific.className = GPBStringifySymbol(RSSpace),
        .number = RSCreateSpaceReq_FieldNumber_Space,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RSCreateSpaceReq__storage_, space),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RSCreateSpaceReq class]
                                     rootClass:[RSSpspacecgiRoot class]
                                          file:RSSpspacecgiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RSCreateSpaceReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001G\000\002E\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RSCreateSpaceResp

@implementation RSCreateSpaceResp

@dynamic hasBaseResp, baseResp;
@dynamic hasSpaceId, spaceId;
@dynamic starIdListArray, starIdListArray_Count;

typedef struct RSCreateSpaceResp__storage_ {
  uint32_t _has_storage_[1];
  RSBaseResp *baseResp;
  RSIdPair *spaceId;
  NSMutableArray *starIdListArray;
} RSCreateSpaceResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResp",
        .dataTypeSpecific.className = GPBStringifySymbol(RSBaseResp),
        .number = RSCreateSpaceResp_FieldNumber_BaseResp,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RSCreateSpaceResp__storage_, baseResp),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "spaceId",
        .dataTypeSpecific.className = GPBStringifySymbol(RSIdPair),
        .number = RSCreateSpaceResp_FieldNumber_SpaceId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RSCreateSpaceResp__storage_, spaceId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "starIdListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(RSIdPair),
        .number = RSCreateSpaceResp_FieldNumber_StarIdListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RSCreateSpaceResp__storage_, starIdListArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RSCreateSpaceResp class]
                                     rootClass:[RSSpspacecgiRoot class]
                                          file:RSSpspacecgiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RSCreateSpaceResp__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001H\000\002G\000\003\000StarIdList\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RSAddStarReq

@implementation RSAddStarReq

@dynamic hasBaseReq, baseReq;
@dynamic hasSpaceId, spaceId;
@dynamic starListArray, starListArray_Count;

typedef struct RSAddStarReq__storage_ {
  uint32_t _has_storage_[1];
  RSBaseReq *baseReq;
  RSIdPair *spaceId;
  NSMutableArray *starListArray;
} RSAddStarReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseReq",
        .dataTypeSpecific.className = GPBStringifySymbol(RSBaseReq),
        .number = RSAddStarReq_FieldNumber_BaseReq,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RSAddStarReq__storage_, baseReq),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "spaceId",
        .dataTypeSpecific.className = GPBStringifySymbol(RSIdPair),
        .number = RSAddStarReq_FieldNumber_SpaceId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RSAddStarReq__storage_, spaceId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "starListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(RSStar),
        .number = RSAddStarReq_FieldNumber_StarListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RSAddStarReq__storage_, starListArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RSAddStarReq class]
                                     rootClass:[RSSpspacecgiRoot class]
                                          file:RSSpspacecgiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RSAddStarReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001G\000\002G\000\003\000StarList\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RSAddStarResp

@implementation RSAddStarResp

@dynamic hasBaseResp, baseResp;
@dynamic starIdListArray, starIdListArray_Count;

typedef struct RSAddStarResp__storage_ {
  uint32_t _has_storage_[1];
  RSBaseResp *baseResp;
  NSMutableArray *starIdListArray;
} RSAddStarResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResp",
        .dataTypeSpecific.className = GPBStringifySymbol(RSBaseResp),
        .number = RSAddStarResp_FieldNumber_BaseResp,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RSAddStarResp__storage_, baseResp),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "starIdListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(RSIdPair),
        .number = RSAddStarResp_FieldNumber_StarIdListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RSAddStarResp__storage_, starIdListArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RSAddStarResp class]
                                     rootClass:[RSSpspacecgiRoot class]
                                          file:RSSpspacecgiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RSAddStarResp__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001H\000\002\000StarIdList\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RSAddCommentReq

@implementation RSAddCommentReq

@dynamic hasBaseReq, baseReq;
@dynamic hasSpaceId, spaceId;
@dynamic hasStarId, starId;
@dynamic hasComment, comment;

typedef struct RSAddCommentReq__storage_ {
  uint32_t _has_storage_[1];
  RSBaseReq *baseReq;
  RSIdPair *spaceId;
  RSIdPair *starId;
  RSComment *comment;
} RSAddCommentReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseReq",
        .dataTypeSpecific.className = GPBStringifySymbol(RSBaseReq),
        .number = RSAddCommentReq_FieldNumber_BaseReq,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RSAddCommentReq__storage_, baseReq),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "spaceId",
        .dataTypeSpecific.className = GPBStringifySymbol(RSIdPair),
        .number = RSAddCommentReq_FieldNumber_SpaceId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RSAddCommentReq__storage_, spaceId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "starId",
        .dataTypeSpecific.className = GPBStringifySymbol(RSIdPair),
        .number = RSAddCommentReq_FieldNumber_StarId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RSAddCommentReq__storage_, starId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "comment",
        .dataTypeSpecific.className = GPBStringifySymbol(RSComment),
        .number = RSAddCommentReq_FieldNumber_Comment,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(RSAddCommentReq__storage_, comment),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RSAddCommentReq class]
                                     rootClass:[RSSpspacecgiRoot class]
                                          file:RSSpspacecgiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RSAddCommentReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\001G\000\002G\000\003F\000\004G\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RSAddCommentResp

@implementation RSAddCommentResp

@dynamic hasBaseResp, baseResp;
@dynamic hasCommentId, commentId;

typedef struct RSAddCommentResp__storage_ {
  uint32_t _has_storage_[1];
  RSBaseResp *baseResp;
  RSIdPair *commentId;
} RSAddCommentResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResp",
        .dataTypeSpecific.className = GPBStringifySymbol(RSBaseResp),
        .number = RSAddCommentResp_FieldNumber_BaseResp,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RSAddCommentResp__storage_, baseResp),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "commentId",
        .dataTypeSpecific.className = GPBStringifySymbol(RSIdPair),
        .number = RSAddCommentResp_FieldNumber_CommentId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RSAddCommentResp__storage_, commentId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RSAddCommentResp class]
                                     rootClass:[RSSpspacecgiRoot class]
                                          file:RSSpspacecgiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RSAddCommentResp__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001H\000\002I\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RSAddAuthorReq

@implementation RSAddAuthorReq

@dynamic hasBaseReq, baseReq;
@dynamic hasSpaceId, spaceId;
@dynamic authorArray, authorArray_Count;

typedef struct RSAddAuthorReq__storage_ {
  uint32_t _has_storage_[1];
  RSBaseReq *baseReq;
  RSIdPair *spaceId;
  NSMutableArray *authorArray;
} RSAddAuthorReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseReq",
        .dataTypeSpecific.className = GPBStringifySymbol(RSBaseReq),
        .number = RSAddAuthorReq_FieldNumber_BaseReq,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RSAddAuthorReq__storage_, baseReq),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "spaceId",
        .dataTypeSpecific.className = GPBStringifySymbol(RSIdPair),
        .number = RSAddAuthorReq_FieldNumber_SpaceId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RSAddAuthorReq__storage_, spaceId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "authorArray",
        .dataTypeSpecific.className = NULL,
        .number = RSAddAuthorReq_FieldNumber_AuthorArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RSAddAuthorReq__storage_, authorArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RSAddAuthorReq class]
                                     rootClass:[RSSpspacecgiRoot class]
                                          file:RSSpspacecgiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RSAddAuthorReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001G\000\002G\000\003\000Author\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RSAddAuthorResp

@implementation RSAddAuthorResp

@dynamic hasBaseResp, baseResp;

typedef struct RSAddAuthorResp__storage_ {
  uint32_t _has_storage_[1];
  RSBaseResp *baseResp;
} RSAddAuthorResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResp",
        .dataTypeSpecific.className = GPBStringifySymbol(RSBaseResp),
        .number = RSAddAuthorResp_FieldNumber_BaseResp,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RSAddAuthorResp__storage_, baseResp),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RSAddAuthorResp class]
                                     rootClass:[RSSpspacecgiRoot class]
                                          file:RSSpspacecgiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RSAddAuthorResp__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001H\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RSGetAllSpaceReq

@implementation RSGetAllSpaceReq

@dynamic hasBaseReq, baseReq;

typedef struct RSGetAllSpaceReq__storage_ {
  uint32_t _has_storage_[1];
  RSBaseReq *baseReq;
} RSGetAllSpaceReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseReq",
        .dataTypeSpecific.className = GPBStringifySymbol(RSBaseReq),
        .number = RSGetAllSpaceReq_FieldNumber_BaseReq,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RSGetAllSpaceReq__storage_, baseReq),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RSGetAllSpaceReq class]
                                     rootClass:[RSSpspacecgiRoot class]
                                          file:RSSpspacecgiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RSGetAllSpaceReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001G\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RSGetAllSpaceResp

@implementation RSGetAllSpaceResp

@dynamic hasBaseResp, baseResp;
@dynamic listArray, listArray_Count;

typedef struct RSGetAllSpaceResp__storage_ {
  uint32_t _has_storage_[1];
  RSBaseResp *baseResp;
  NSMutableArray *listArray;
} RSGetAllSpaceResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResp",
        .dataTypeSpecific.className = GPBStringifySymbol(RSBaseResp),
        .number = RSGetAllSpaceResp_FieldNumber_BaseResp,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RSGetAllSpaceResp__storage_, baseResp),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(RSSpace),
        .number = RSGetAllSpaceResp_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RSGetAllSpaceResp__storage_, listArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RSGetAllSpaceResp class]
                                     rootClass:[RSSpspacecgiRoot class]
                                          file:RSSpspacecgiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RSGetAllSpaceResp__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001H\000\002\000List\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RSGetAllMySpaceReq

@implementation RSGetAllMySpaceReq

@dynamic hasBaseReq, baseReq;

typedef struct RSGetAllMySpaceReq__storage_ {
  uint32_t _has_storage_[1];
  RSBaseReq *baseReq;
} RSGetAllMySpaceReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseReq",
        .dataTypeSpecific.className = GPBStringifySymbol(RSBaseReq),
        .number = RSGetAllMySpaceReq_FieldNumber_BaseReq,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RSGetAllMySpaceReq__storage_, baseReq),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RSGetAllMySpaceReq class]
                                     rootClass:[RSSpspacecgiRoot class]
                                          file:RSSpspacecgiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RSGetAllMySpaceReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001G\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RSGetAllMySpaceResp

@implementation RSGetAllMySpaceResp

@dynamic hasBaseResp, baseResp;
@dynamic listArray, listArray_Count;

typedef struct RSGetAllMySpaceResp__storage_ {
  uint32_t _has_storage_[1];
  RSBaseResp *baseResp;
  NSMutableArray *listArray;
} RSGetAllMySpaceResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResp",
        .dataTypeSpecific.className = GPBStringifySymbol(RSBaseResp),
        .number = RSGetAllMySpaceResp_FieldNumber_BaseResp,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RSGetAllMySpaceResp__storage_, baseResp),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(RSSpace),
        .number = RSGetAllMySpaceResp_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RSGetAllMySpaceResp__storage_, listArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RSGetAllMySpaceResp class]
                                     rootClass:[RSSpspacecgiRoot class]
                                          file:RSSpspacecgiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RSGetAllMySpaceResp__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001H\000\002\000List\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RSGetAllMemoirReq

@implementation RSGetAllMemoirReq

@dynamic hasBaseReq, baseReq;

typedef struct RSGetAllMemoirReq__storage_ {
  uint32_t _has_storage_[1];
  RSBaseReq *baseReq;
} RSGetAllMemoirReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseReq",
        .dataTypeSpecific.className = GPBStringifySymbol(RSBaseReq),
        .number = RSGetAllMemoirReq_FieldNumber_BaseReq,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RSGetAllMemoirReq__storage_, baseReq),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RSGetAllMemoirReq class]
                                     rootClass:[RSSpspacecgiRoot class]
                                          file:RSSpspacecgiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RSGetAllMemoirReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001G\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RSGetAllMemoirResp

@implementation RSGetAllMemoirResp

@dynamic hasBaseResp, baseResp;
@dynamic listArray, listArray_Count;

typedef struct RSGetAllMemoirResp__storage_ {
  uint32_t _has_storage_[1];
  RSBaseResp *baseResp;
  NSMutableArray *listArray;
} RSGetAllMemoirResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResp",
        .dataTypeSpecific.className = GPBStringifySymbol(RSBaseResp),
        .number = RSGetAllMemoirResp_FieldNumber_BaseResp,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RSGetAllMemoirResp__storage_, baseResp),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(RSSpace),
        .number = RSGetAllMemoirResp_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RSGetAllMemoirResp__storage_, listArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RSGetAllMemoirResp class]
                                     rootClass:[RSSpspacecgiRoot class]
                                          file:RSSpspacecgiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RSGetAllMemoirResp__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001H\000\002\000List\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RSAddMemoirReq

@implementation RSAddMemoirReq

@dynamic hasBaseReq, baseReq;
@dynamic hasSpaceId, spaceId;

typedef struct RSAddMemoirReq__storage_ {
  uint32_t _has_storage_[1];
  RSBaseReq *baseReq;
  RSIdPair *spaceId;
} RSAddMemoirReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseReq",
        .dataTypeSpecific.className = GPBStringifySymbol(RSBaseReq),
        .number = RSAddMemoirReq_FieldNumber_BaseReq,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RSAddMemoirReq__storage_, baseReq),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "spaceId",
        .dataTypeSpecific.className = GPBStringifySymbol(RSIdPair),
        .number = RSAddMemoirReq_FieldNumber_SpaceId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RSAddMemoirReq__storage_, spaceId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RSAddMemoirReq class]
                                     rootClass:[RSSpspacecgiRoot class]
                                          file:RSSpspacecgiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RSAddMemoirReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001G\000\002G\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RSAddMemoirResp

@implementation RSAddMemoirResp

@dynamic hasBaseResp, baseResp;

typedef struct RSAddMemoirResp__storage_ {
  uint32_t _has_storage_[1];
  RSBaseResp *baseResp;
} RSAddMemoirResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResp",
        .dataTypeSpecific.className = GPBStringifySymbol(RSBaseResp),
        .number = RSAddMemoirResp_FieldNumber_BaseResp,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RSAddMemoirResp__storage_, baseResp),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RSAddMemoirResp class]
                                     rootClass:[RSSpspacecgiRoot class]
                                          file:RSSpspacecgiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RSAddMemoirResp__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001H\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
