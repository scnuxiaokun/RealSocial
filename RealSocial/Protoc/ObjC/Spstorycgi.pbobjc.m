// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: spstorycgi.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

 #import "Spstorycgi.pbobjc.h"
 #import "Spcgicomm.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - RSSpstorycgiRoot

@implementation RSSpstorycgiRoot

// No extensions in the file and none of the imports (direct or indirect)
// defined extensions, so no need to generate +extensionRegistry.

@end

#pragma mark - RSSpstorycgiRoot_FileDescriptor

static GPBFileDescriptor *RSSpstorycgiRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"spcgi"
                                                 objcPrefix:@"RS"
                                                     syntax:GPBFileSyntaxProto2];
  }
  return descriptor;
}

#pragma mark - Enum RSenStoryType

GPBEnumDescriptor *RSenStoryType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "StoryTypePrivate\000StoryTypePublic\000";
    static const int32_t values[] = {
        RSenStoryType_StoryTypePrivate,
        RSenStoryType_StoryTypePublic,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(RSenStoryType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:RSenStoryType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL RSenStoryType_IsValidValue(int32_t value__) {
  switch (value__) {
    case RSenStoryType_StoryTypePrivate:
    case RSenStoryType_StoryTypePublic:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum RSenStoryItemType

GPBEnumDescriptor *RSenStoryItemType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "StoryItemTypeImg\000StoryItemTypeVideo\000";
    static const int32_t values[] = {
        RSenStoryItemType_StoryItemTypeImg,
        RSenStoryItemType_StoryItemTypeVideo,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(RSenStoryItemType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:RSenStoryItemType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL RSenStoryItemType_IsValidValue(int32_t value__) {
  switch (value__) {
    case RSenStoryItemType_StoryItemTypeImg:
    case RSenStoryItemType_StoryItemTypeVideo:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum RSenStoryToType

GPBEnumDescriptor *RSenStoryToType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "StoryToTypeUser\000StoryToTypeGroup\000";
    static const int32_t values[] = {
        RSenStoryToType_StoryToTypeUser,
        RSenStoryToType_StoryToTypeGroup,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(RSenStoryToType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:RSenStoryToType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL RSenStoryToType_IsValidValue(int32_t value__) {
  switch (value__) {
    case RSenStoryToType_StoryToTypeUser:
    case RSenStoryToType_StoryToTypeGroup:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - RSStoryImg

@implementation RSStoryImg

@dynamic hasThumbURL, thumbURL;
@dynamic hasImgRl, imgRl;

typedef struct RSStoryImg__storage_ {
  uint32_t _has_storage_[1];
  NSString *thumbURL;
  NSString *imgRl;
} RSStoryImg__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "thumbURL",
        .dataTypeSpecific.className = NULL,
        .number = RSStoryImg_FieldNumber_ThumbURL,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RSStoryImg__storage_, thumbURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "imgRl",
        .dataTypeSpecific.className = NULL,
        .number = RSStoryImg_FieldNumber_ImgRl,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RSStoryImg__storage_, imgRl),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RSStoryImg class]
                                     rootClass:[RSSpstorycgiRoot class]
                                          file:RSSpstorycgiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RSStoryImg__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001H\000\002DA\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RSStoryVideo

@implementation RSStoryVideo

@dynamic hasThumbURL, thumbURL;
@dynamic hasVideoURL, videoURL;

typedef struct RSStoryVideo__storage_ {
  uint32_t _has_storage_[1];
  NSString *thumbURL;
  NSString *videoURL;
} RSStoryVideo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "thumbURL",
        .dataTypeSpecific.className = NULL,
        .number = RSStoryVideo_FieldNumber_ThumbURL,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RSStoryVideo__storage_, thumbURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "videoURL",
        .dataTypeSpecific.className = NULL,
        .number = RSStoryVideo_FieldNumber_VideoURL,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RSStoryVideo__storage_, videoURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RSStoryVideo class]
                                     rootClass:[RSSpstorycgiRoot class]
                                          file:RSSpstorycgiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RSStoryVideo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001H\000\002H\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RSStoryItem

@implementation RSStoryItem

@dynamic hasType, type;
@dynamic hasFromUserName, fromUserName;
@dynamic hasImg, img;
@dynamic hasVideo, video;

typedef struct RSStoryItem__storage_ {
  uint32_t _has_storage_[1];
  uint32_t type;
  NSString *fromUserName;
  RSStoryImg *img;
  RSStoryVideo *video;
} RSStoryItem__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.className = NULL,
        .number = RSStoryItem_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RSStoryItem__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "fromUserName",
        .dataTypeSpecific.className = NULL,
        .number = RSStoryItem_FieldNumber_FromUserName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RSStoryItem__storage_, fromUserName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "img",
        .dataTypeSpecific.className = GPBStringifySymbol(RSStoryImg),
        .number = RSStoryItem_FieldNumber_Img,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RSStoryItem__storage_, img),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "video",
        .dataTypeSpecific.className = GPBStringifySymbol(RSStoryVideo),
        .number = RSStoryItem_FieldNumber_Video,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(RSStoryItem__storage_, video),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RSStoryItem class]
                                     rootClass:[RSSpstorycgiRoot class]
                                          file:RSSpstorycgiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RSStoryItem__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\001D\000\002L\000\003C\000\004E\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RSStoryToItem

@implementation RSStoryToItem

@dynamic hasType, type;
@dynamic toUserNameArray, toUserNameArray_Count;
@dynamic hasGroupId, groupId;

typedef struct RSStoryToItem__storage_ {
  uint32_t _has_storage_[1];
  uint32_t type;
  uint32_t groupId;
  NSMutableArray *toUserNameArray;
} RSStoryToItem__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.className = NULL,
        .number = RSStoryToItem_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RSStoryToItem__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "toUserNameArray",
        .dataTypeSpecific.className = NULL,
        .number = RSStoryToItem_FieldNumber_ToUserNameArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RSStoryToItem__storage_, toUserNameArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "groupId",
        .dataTypeSpecific.className = NULL,
        .number = RSStoryToItem_FieldNumber_GroupId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RSStoryToItem__storage_, groupId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RSStoryToItem class]
                                     rootClass:[RSSpstorycgiRoot class]
                                          file:RSSpstorycgiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RSStoryToItem__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001D\000\002\000ToUserName\000\003G\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RSStory

@implementation RSStory

@dynamic hasType, type;
@dynamic hasClientId, clientId;
@dynamic hasTo, to;
@dynamic itemArray, itemArray_Count;
@dynamic hasSvrId, svrId;

typedef struct RSStory__storage_ {
  uint32_t _has_storage_[1];
  uint32_t type;
  NSString *clientId;
  RSStoryToItem *to;
  NSMutableArray *itemArray;
  uint64_t svrId;
} RSStory__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.className = NULL,
        .number = RSStory_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RSStory__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "clientId",
        .dataTypeSpecific.className = NULL,
        .number = RSStory_FieldNumber_ClientId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RSStory__storage_, clientId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "to",
        .dataTypeSpecific.className = GPBStringifySymbol(RSStoryToItem),
        .number = RSStory_FieldNumber_To,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RSStory__storage_, to),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "itemArray",
        .dataTypeSpecific.className = GPBStringifySymbol(RSStoryItem),
        .number = RSStory_FieldNumber_ItemArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RSStory__storage_, itemArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "svrId",
        .dataTypeSpecific.className = NULL,
        .number = RSStory_FieldNumber_SvrId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(RSStory__storage_, svrId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RSStory class]
                                     rootClass:[RSSpstorycgiRoot class]
                                          file:RSSpstorycgiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RSStory__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\005\002D\000\003H\000\004B\000\005\000Item\000\006E\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RSCreateStoryReq

@implementation RSCreateStoryReq

@dynamic hasBaseReq, baseReq;
@dynamic hasStory, story;

typedef struct RSCreateStoryReq__storage_ {
  uint32_t _has_storage_[1];
  RSBaseReq *baseReq;
  RSStory *story;
} RSCreateStoryReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseReq",
        .dataTypeSpecific.className = GPBStringifySymbol(RSBaseReq),
        .number = RSCreateStoryReq_FieldNumber_BaseReq,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RSCreateStoryReq__storage_, baseReq),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "story",
        .dataTypeSpecific.className = GPBStringifySymbol(RSStory),
        .number = RSCreateStoryReq_FieldNumber_Story,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RSCreateStoryReq__storage_, story),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RSCreateStoryReq class]
                                     rootClass:[RSSpstorycgiRoot class]
                                          file:RSSpstorycgiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RSCreateStoryReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001G\000\002E\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RSCreateStoryResp

@implementation RSCreateStoryResp

@dynamic hasBaseResp, baseResp;
@dynamic hasSvrId, svrId;

typedef struct RSCreateStoryResp__storage_ {
  uint32_t _has_storage_[1];
  RSBaseResp *baseResp;
  uint64_t svrId;
} RSCreateStoryResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResp",
        .dataTypeSpecific.className = GPBStringifySymbol(RSBaseResp),
        .number = RSCreateStoryResp_FieldNumber_BaseResp,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RSCreateStoryResp__storage_, baseResp),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "svrId",
        .dataTypeSpecific.className = NULL,
        .number = RSCreateStoryResp_FieldNumber_SvrId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RSCreateStoryResp__storage_, svrId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RSCreateStoryResp class]
                                     rootClass:[RSSpstorycgiRoot class]
                                          file:RSSpstorycgiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RSCreateStoryResp__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001H\000\002E\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RSAppendStoryReq

@implementation RSAppendStoryReq

@dynamic hasBaseReq, baseReq;
@dynamic hasStory, story;

typedef struct RSAppendStoryReq__storage_ {
  uint32_t _has_storage_[1];
  RSBaseReq *baseReq;
  RSStory *story;
} RSAppendStoryReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseReq",
        .dataTypeSpecific.className = GPBStringifySymbol(RSBaseReq),
        .number = RSAppendStoryReq_FieldNumber_BaseReq,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RSAppendStoryReq__storage_, baseReq),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "story",
        .dataTypeSpecific.className = GPBStringifySymbol(RSStory),
        .number = RSAppendStoryReq_FieldNumber_Story,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RSAppendStoryReq__storage_, story),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RSAppendStoryReq class]
                                     rootClass:[RSSpstorycgiRoot class]
                                          file:RSSpstorycgiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RSAppendStoryReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001G\000\002E\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RSAppendStoryResp

@implementation RSAppendStoryResp

@dynamic hasBaseResp, baseResp;

typedef struct RSAppendStoryResp__storage_ {
  uint32_t _has_storage_[1];
  RSBaseResp *baseResp;
} RSAppendStoryResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResp",
        .dataTypeSpecific.className = GPBStringifySymbol(RSBaseResp),
        .number = RSAppendStoryResp_FieldNumber_BaseResp,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RSAppendStoryResp__storage_, baseResp),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RSAppendStoryResp class]
                                     rootClass:[RSSpstorycgiRoot class]
                                          file:RSSpstorycgiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RSAppendStoryResp__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001H\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RSAppendStoryToReq

@implementation RSAppendStoryToReq

@dynamic hasBaseReq, baseReq;
@dynamic hasSvrId, svrId;
@dynamic hasTo, to;

typedef struct RSAppendStoryToReq__storage_ {
  uint32_t _has_storage_[1];
  RSBaseReq *baseReq;
  RSStoryToItem *to;
  uint64_t svrId;
} RSAppendStoryToReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseReq",
        .dataTypeSpecific.className = GPBStringifySymbol(RSBaseReq),
        .number = RSAppendStoryToReq_FieldNumber_BaseReq,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RSAppendStoryToReq__storage_, baseReq),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "svrId",
        .dataTypeSpecific.className = NULL,
        .number = RSAppendStoryToReq_FieldNumber_SvrId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RSAppendStoryToReq__storage_, svrId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "to",
        .dataTypeSpecific.className = GPBStringifySymbol(RSStoryToItem),
        .number = RSAppendStoryToReq_FieldNumber_To,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RSAppendStoryToReq__storage_, to),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RSAppendStoryToReq class]
                                     rootClass:[RSSpstorycgiRoot class]
                                          file:RSSpstorycgiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RSAppendStoryToReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001G\000\002E\000\003B\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RSAppendStoryToResp

@implementation RSAppendStoryToResp

@dynamic hasBaseResp, baseResp;

typedef struct RSAppendStoryToResp__storage_ {
  uint32_t _has_storage_[1];
  RSBaseResp *baseResp;
} RSAppendStoryToResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResp",
        .dataTypeSpecific.className = GPBStringifySymbol(RSBaseResp),
        .number = RSAppendStoryToResp_FieldNumber_BaseResp,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RSAppendStoryToResp__storage_, baseResp),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RSAppendStoryToResp class]
                                     rootClass:[RSSpstorycgiRoot class]
                                          file:RSSpstorycgiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RSAppendStoryToResp__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001H\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RSGetAllStoryReq

@implementation RSGetAllStoryReq

@dynamic hasBaseReq, baseReq;

typedef struct RSGetAllStoryReq__storage_ {
  uint32_t _has_storage_[1];
  RSBaseReq *baseReq;
} RSGetAllStoryReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseReq",
        .dataTypeSpecific.className = GPBStringifySymbol(RSBaseReq),
        .number = RSGetAllStoryReq_FieldNumber_BaseReq,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RSGetAllStoryReq__storage_, baseReq),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RSGetAllStoryReq class]
                                     rootClass:[RSSpstorycgiRoot class]
                                          file:RSSpstorycgiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RSGetAllStoryReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001G\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RSGetAllStoryResp

@implementation RSGetAllStoryResp

@dynamic hasBaseResp, baseResp;
@dynamic listArray, listArray_Count;

typedef struct RSGetAllStoryResp__storage_ {
  uint32_t _has_storage_[1];
  RSBaseResp *baseResp;
  NSMutableArray *listArray;
} RSGetAllStoryResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResp",
        .dataTypeSpecific.className = GPBStringifySymbol(RSBaseResp),
        .number = RSGetAllStoryResp_FieldNumber_BaseResp,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RSGetAllStoryResp__storage_, baseResp),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(RSStory),
        .number = RSGetAllStoryResp_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RSGetAllStoryResp__storage_, listArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RSGetAllStoryResp class]
                                     rootClass:[RSSpstorycgiRoot class]
                                          file:RSSpstorycgiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RSGetAllStoryResp__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001H\000\002\000List\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RSGetAllMyStoryReq

@implementation RSGetAllMyStoryReq

@dynamic hasBaseReq, baseReq;

typedef struct RSGetAllMyStoryReq__storage_ {
  uint32_t _has_storage_[1];
  RSBaseReq *baseReq;
} RSGetAllMyStoryReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseReq",
        .dataTypeSpecific.className = GPBStringifySymbol(RSBaseReq),
        .number = RSGetAllMyStoryReq_FieldNumber_BaseReq,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RSGetAllMyStoryReq__storage_, baseReq),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RSGetAllMyStoryReq class]
                                     rootClass:[RSSpstorycgiRoot class]
                                          file:RSSpstorycgiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RSGetAllMyStoryReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001G\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RSGetAllMyStoryResp

@implementation RSGetAllMyStoryResp

@dynamic hasBaseResp, baseResp;
@dynamic listArray, listArray_Count;

typedef struct RSGetAllMyStoryResp__storage_ {
  uint32_t _has_storage_[1];
  RSBaseResp *baseResp;
  NSMutableArray *listArray;
} RSGetAllMyStoryResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResp",
        .dataTypeSpecific.className = GPBStringifySymbol(RSBaseResp),
        .number = RSGetAllMyStoryResp_FieldNumber_BaseResp,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RSGetAllMyStoryResp__storage_, baseResp),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(RSStory),
        .number = RSGetAllMyStoryResp_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RSGetAllMyStoryResp__storage_, listArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RSGetAllMyStoryResp class]
                                     rootClass:[RSSpstorycgiRoot class]
                                          file:RSSpstorycgiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RSGetAllMyStoryResp__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001H\000\002\000List\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RSGetAllMyMemoryReq

@implementation RSGetAllMyMemoryReq

@dynamic hasBaseReq, baseReq;

typedef struct RSGetAllMyMemoryReq__storage_ {
  uint32_t _has_storage_[1];
  RSBaseReq *baseReq;
} RSGetAllMyMemoryReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseReq",
        .dataTypeSpecific.className = GPBStringifySymbol(RSBaseReq),
        .number = RSGetAllMyMemoryReq_FieldNumber_BaseReq,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RSGetAllMyMemoryReq__storage_, baseReq),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RSGetAllMyMemoryReq class]
                                     rootClass:[RSSpstorycgiRoot class]
                                          file:RSSpstorycgiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RSGetAllMyMemoryReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001G\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RSGetAllMyMemoryResp

@implementation RSGetAllMyMemoryResp

@dynamic hasBaseResp, baseResp;
@dynamic listArray, listArray_Count;

typedef struct RSGetAllMyMemoryResp__storage_ {
  uint32_t _has_storage_[1];
  RSBaseResp *baseResp;
  NSMutableArray *listArray;
} RSGetAllMyMemoryResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResp",
        .dataTypeSpecific.className = GPBStringifySymbol(RSBaseResp),
        .number = RSGetAllMyMemoryResp_FieldNumber_BaseResp,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RSGetAllMyMemoryResp__storage_, baseResp),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(RSStory),
        .number = RSGetAllMyMemoryResp_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RSGetAllMyMemoryResp__storage_, listArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RSGetAllMyMemoryResp class]
                                     rootClass:[RSSpstorycgiRoot class]
                                          file:RSSpstorycgiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RSGetAllMyMemoryResp__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001H\000\002\000List\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RSAddMyMemoryReq

@implementation RSAddMyMemoryReq

@dynamic hasBaseReq, baseReq;
@dynamic hasSvrId, svrId;

typedef struct RSAddMyMemoryReq__storage_ {
  uint32_t _has_storage_[1];
  RSBaseReq *baseReq;
  NSString *svrId;
} RSAddMyMemoryReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseReq",
        .dataTypeSpecific.className = GPBStringifySymbol(RSBaseReq),
        .number = RSAddMyMemoryReq_FieldNumber_BaseReq,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RSAddMyMemoryReq__storage_, baseReq),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "svrId",
        .dataTypeSpecific.className = NULL,
        .number = RSAddMyMemoryReq_FieldNumber_SvrId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RSAddMyMemoryReq__storage_, svrId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RSAddMyMemoryReq class]
                                     rootClass:[RSSpstorycgiRoot class]
                                          file:RSSpstorycgiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RSAddMyMemoryReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001G\000\002E\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RSAddMyMemoryResp

@implementation RSAddMyMemoryResp

@dynamic hasBaseResp, baseResp;

typedef struct RSAddMyMemoryResp__storage_ {
  uint32_t _has_storage_[1];
  RSBaseResp *baseResp;
} RSAddMyMemoryResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResp",
        .dataTypeSpecific.className = GPBStringifySymbol(RSBaseResp),
        .number = RSAddMyMemoryResp_FieldNumber_BaseResp,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RSAddMyMemoryResp__storage_, baseResp),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RSAddMyMemoryResp class]
                                     rootClass:[RSSpstorycgiRoot class]
                                          file:RSSpstorycgiRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RSAddMyMemoryResp__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001H\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
